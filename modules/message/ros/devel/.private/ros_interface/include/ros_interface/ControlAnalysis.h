// Generated by gencpp from file ros_interface/ControlAnalysis.msg
// DO NOT EDIT!


#ifndef ROS_INTERFACE_MESSAGE_CONTROLANALYSIS_H
#define ROS_INTERFACE_MESSAGE_CONTROLANALYSIS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace ros_interface
{
template <class ContainerAllocator>
struct ControlAnalysis_
{
  typedef ControlAnalysis_<ContainerAllocator> Type;

  ControlAnalysis_()
    : header()
    , driving_mode(0)
    , driving_mode_fd(0)
    , gear_location_fd(0)
    , gear_location_cmd(0)
    , epb_level_fd(0)
    , epb_level_cmd(0)
    , speed_mps(0.0)
    , speed_reference(0.0)
    , accel_value_fd(0.0)
    , accel_value_cmd(0.0)
    , brake_value_fd(0.0)
    , brake_value_cmd(0.0)
    , path_remain(0.0)
    , has_stop_point(false)
    , is_full_stop(false)
    , is_stopped(false)
    , lon_acc_jerk(0.0)
    , acceleration_cmd(0.0)
    , acceleration_cmd_closeloop(0.0)
    , preview_acceleration_reference(0.0)
    , slope_offset_compensation(0.0)
    , turning_offset_compensation(0.0)
    , speed_error_limited(0.0)
    , speed_error(0.0)
    , speed_offset(0.0)
    , station_error_limited(0.0)
    , station_error(0.0)
    , lon_target_point_s(0.0)
    , lon_calculate_time(0)
    , lon_calculate_time_max(0)
    , ref_curvature(0.0)
    , ref_heading(0.0)
    , current_heading(0.0)
    , heading_error(0.0)
    , heading_error_rate(0.0)
    , lateral_error(0.0)
    , lateral_error_rate(0.0)
    , lon_error(0.0)
    , front_steering_value_fd(0.0)
    , front_steering_target(0.0)
    , front_steering_rate(0.0)
    , front_steer_angle_feedforward(0.0)
    , front_steer_angle_feedback(0.0)
    , front_steer_angle_lateral_contribution(0.0)
    , front_steer_angle_lateral_rate_contribution(0.0)
    , front_steer_angle_heading_contribution(0.0)
    , front_steer_angle_heading_rate_contribution(0.0)
    , rear_steering_value_fd(0.0)
    , rear_steering_target(0.0)
    , rear_steering_rate(0.0)
    , rear_steer_angle_feedforward(0.0)
    , rear_steer_angle_feedback(0.0)
    , rear_steer_angle_lateral_contribution(0.0)
    , rear_steer_angle_lateral_rate_contribution(0.0)
    , rear_steer_angle_heading_contribution(0.0)
    , rear_steer_angle_heading_rate_contribution(0.0)
    , matrix_k_00(0.0)
    , matrix_k_01(0.0)
    , matrix_k_02(0.0)
    , matrix_k_03(0.0)
    , matrix_k_10(0.0)
    , matrix_k_11(0.0)
    , matrix_k_12(0.0)
    , matrix_k_13(0.0)
    , matrix_state_0(0.0)
    , matrix_state_1(0.0)
    , matrix_state_2(0.0)
    , matrix_state_3(0.0)
    , matrix_q_updated_0(0.0)
    , matrix_q_updated_1(0.0)
    , matrix_q_updated_2(0.0)
    , matrix_q_updated_3(0.0)
    , current_x(0.0)
    , current_y(0.0)
    , target_point_x(0.0)
    , target_point_y(0.0)
    , lat_target_point_s(0.0)
    , lqr_calculate_time(0)
    , lqr_calculate_time_max(0)  {
    }
  ControlAnalysis_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , driving_mode(0)
    , driving_mode_fd(0)
    , gear_location_fd(0)
    , gear_location_cmd(0)
    , epb_level_fd(0)
    , epb_level_cmd(0)
    , speed_mps(0.0)
    , speed_reference(0.0)
    , accel_value_fd(0.0)
    , accel_value_cmd(0.0)
    , brake_value_fd(0.0)
    , brake_value_cmd(0.0)
    , path_remain(0.0)
    , has_stop_point(false)
    , is_full_stop(false)
    , is_stopped(false)
    , lon_acc_jerk(0.0)
    , acceleration_cmd(0.0)
    , acceleration_cmd_closeloop(0.0)
    , preview_acceleration_reference(0.0)
    , slope_offset_compensation(0.0)
    , turning_offset_compensation(0.0)
    , speed_error_limited(0.0)
    , speed_error(0.0)
    , speed_offset(0.0)
    , station_error_limited(0.0)
    , station_error(0.0)
    , lon_target_point_s(0.0)
    , lon_calculate_time(0)
    , lon_calculate_time_max(0)
    , ref_curvature(0.0)
    , ref_heading(0.0)
    , current_heading(0.0)
    , heading_error(0.0)
    , heading_error_rate(0.0)
    , lateral_error(0.0)
    , lateral_error_rate(0.0)
    , lon_error(0.0)
    , front_steering_value_fd(0.0)
    , front_steering_target(0.0)
    , front_steering_rate(0.0)
    , front_steer_angle_feedforward(0.0)
    , front_steer_angle_feedback(0.0)
    , front_steer_angle_lateral_contribution(0.0)
    , front_steer_angle_lateral_rate_contribution(0.0)
    , front_steer_angle_heading_contribution(0.0)
    , front_steer_angle_heading_rate_contribution(0.0)
    , rear_steering_value_fd(0.0)
    , rear_steering_target(0.0)
    , rear_steering_rate(0.0)
    , rear_steer_angle_feedforward(0.0)
    , rear_steer_angle_feedback(0.0)
    , rear_steer_angle_lateral_contribution(0.0)
    , rear_steer_angle_lateral_rate_contribution(0.0)
    , rear_steer_angle_heading_contribution(0.0)
    , rear_steer_angle_heading_rate_contribution(0.0)
    , matrix_k_00(0.0)
    , matrix_k_01(0.0)
    , matrix_k_02(0.0)
    , matrix_k_03(0.0)
    , matrix_k_10(0.0)
    , matrix_k_11(0.0)
    , matrix_k_12(0.0)
    , matrix_k_13(0.0)
    , matrix_state_0(0.0)
    , matrix_state_1(0.0)
    , matrix_state_2(0.0)
    , matrix_state_3(0.0)
    , matrix_q_updated_0(0.0)
    , matrix_q_updated_1(0.0)
    , matrix_q_updated_2(0.0)
    , matrix_q_updated_3(0.0)
    , current_x(0.0)
    , current_y(0.0)
    , target_point_x(0.0)
    , target_point_y(0.0)
    , lat_target_point_s(0.0)
    , lqr_calculate_time(0)
    , lqr_calculate_time_max(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int32_t _driving_mode_type;
  _driving_mode_type driving_mode;

   typedef int32_t _driving_mode_fd_type;
  _driving_mode_fd_type driving_mode_fd;

   typedef int32_t _gear_location_fd_type;
  _gear_location_fd_type gear_location_fd;

   typedef int32_t _gear_location_cmd_type;
  _gear_location_cmd_type gear_location_cmd;

   typedef int32_t _epb_level_fd_type;
  _epb_level_fd_type epb_level_fd;

   typedef int32_t _epb_level_cmd_type;
  _epb_level_cmd_type epb_level_cmd;

   typedef double _speed_mps_type;
  _speed_mps_type speed_mps;

   typedef double _speed_reference_type;
  _speed_reference_type speed_reference;

   typedef double _accel_value_fd_type;
  _accel_value_fd_type accel_value_fd;

   typedef double _accel_value_cmd_type;
  _accel_value_cmd_type accel_value_cmd;

   typedef double _brake_value_fd_type;
  _brake_value_fd_type brake_value_fd;

   typedef double _brake_value_cmd_type;
  _brake_value_cmd_type brake_value_cmd;

   typedef double _path_remain_type;
  _path_remain_type path_remain;

   typedef uint8_t _has_stop_point_type;
  _has_stop_point_type has_stop_point;

   typedef uint8_t _is_full_stop_type;
  _is_full_stop_type is_full_stop;

   typedef uint8_t _is_stopped_type;
  _is_stopped_type is_stopped;

   typedef double _lon_acc_jerk_type;
  _lon_acc_jerk_type lon_acc_jerk;

   typedef double _acceleration_cmd_type;
  _acceleration_cmd_type acceleration_cmd;

   typedef double _acceleration_cmd_closeloop_type;
  _acceleration_cmd_closeloop_type acceleration_cmd_closeloop;

   typedef double _preview_acceleration_reference_type;
  _preview_acceleration_reference_type preview_acceleration_reference;

   typedef double _slope_offset_compensation_type;
  _slope_offset_compensation_type slope_offset_compensation;

   typedef double _turning_offset_compensation_type;
  _turning_offset_compensation_type turning_offset_compensation;

   typedef double _speed_error_limited_type;
  _speed_error_limited_type speed_error_limited;

   typedef double _speed_error_type;
  _speed_error_type speed_error;

   typedef double _speed_offset_type;
  _speed_offset_type speed_offset;

   typedef double _station_error_limited_type;
  _station_error_limited_type station_error_limited;

   typedef double _station_error_type;
  _station_error_type station_error;

   typedef double _lon_target_point_s_type;
  _lon_target_point_s_type lon_target_point_s;

   typedef int64_t _lon_calculate_time_type;
  _lon_calculate_time_type lon_calculate_time;

   typedef int64_t _lon_calculate_time_max_type;
  _lon_calculate_time_max_type lon_calculate_time_max;

   typedef double _ref_curvature_type;
  _ref_curvature_type ref_curvature;

   typedef double _ref_heading_type;
  _ref_heading_type ref_heading;

   typedef double _current_heading_type;
  _current_heading_type current_heading;

   typedef double _heading_error_type;
  _heading_error_type heading_error;

   typedef double _heading_error_rate_type;
  _heading_error_rate_type heading_error_rate;

   typedef double _lateral_error_type;
  _lateral_error_type lateral_error;

   typedef double _lateral_error_rate_type;
  _lateral_error_rate_type lateral_error_rate;

   typedef double _lon_error_type;
  _lon_error_type lon_error;

   typedef double _front_steering_value_fd_type;
  _front_steering_value_fd_type front_steering_value_fd;

   typedef double _front_steering_target_type;
  _front_steering_target_type front_steering_target;

   typedef double _front_steering_rate_type;
  _front_steering_rate_type front_steering_rate;

   typedef double _front_steer_angle_feedforward_type;
  _front_steer_angle_feedforward_type front_steer_angle_feedforward;

   typedef double _front_steer_angle_feedback_type;
  _front_steer_angle_feedback_type front_steer_angle_feedback;

   typedef double _front_steer_angle_lateral_contribution_type;
  _front_steer_angle_lateral_contribution_type front_steer_angle_lateral_contribution;

   typedef double _front_steer_angle_lateral_rate_contribution_type;
  _front_steer_angle_lateral_rate_contribution_type front_steer_angle_lateral_rate_contribution;

   typedef double _front_steer_angle_heading_contribution_type;
  _front_steer_angle_heading_contribution_type front_steer_angle_heading_contribution;

   typedef double _front_steer_angle_heading_rate_contribution_type;
  _front_steer_angle_heading_rate_contribution_type front_steer_angle_heading_rate_contribution;

   typedef double _rear_steering_value_fd_type;
  _rear_steering_value_fd_type rear_steering_value_fd;

   typedef double _rear_steering_target_type;
  _rear_steering_target_type rear_steering_target;

   typedef double _rear_steering_rate_type;
  _rear_steering_rate_type rear_steering_rate;

   typedef double _rear_steer_angle_feedforward_type;
  _rear_steer_angle_feedforward_type rear_steer_angle_feedforward;

   typedef double _rear_steer_angle_feedback_type;
  _rear_steer_angle_feedback_type rear_steer_angle_feedback;

   typedef double _rear_steer_angle_lateral_contribution_type;
  _rear_steer_angle_lateral_contribution_type rear_steer_angle_lateral_contribution;

   typedef double _rear_steer_angle_lateral_rate_contribution_type;
  _rear_steer_angle_lateral_rate_contribution_type rear_steer_angle_lateral_rate_contribution;

   typedef double _rear_steer_angle_heading_contribution_type;
  _rear_steer_angle_heading_contribution_type rear_steer_angle_heading_contribution;

   typedef double _rear_steer_angle_heading_rate_contribution_type;
  _rear_steer_angle_heading_rate_contribution_type rear_steer_angle_heading_rate_contribution;

   typedef double _matrix_k_00_type;
  _matrix_k_00_type matrix_k_00;

   typedef double _matrix_k_01_type;
  _matrix_k_01_type matrix_k_01;

   typedef double _matrix_k_02_type;
  _matrix_k_02_type matrix_k_02;

   typedef double _matrix_k_03_type;
  _matrix_k_03_type matrix_k_03;

   typedef double _matrix_k_10_type;
  _matrix_k_10_type matrix_k_10;

   typedef double _matrix_k_11_type;
  _matrix_k_11_type matrix_k_11;

   typedef double _matrix_k_12_type;
  _matrix_k_12_type matrix_k_12;

   typedef double _matrix_k_13_type;
  _matrix_k_13_type matrix_k_13;

   typedef double _matrix_state_0_type;
  _matrix_state_0_type matrix_state_0;

   typedef double _matrix_state_1_type;
  _matrix_state_1_type matrix_state_1;

   typedef double _matrix_state_2_type;
  _matrix_state_2_type matrix_state_2;

   typedef double _matrix_state_3_type;
  _matrix_state_3_type matrix_state_3;

   typedef double _matrix_q_updated_0_type;
  _matrix_q_updated_0_type matrix_q_updated_0;

   typedef double _matrix_q_updated_1_type;
  _matrix_q_updated_1_type matrix_q_updated_1;

   typedef double _matrix_q_updated_2_type;
  _matrix_q_updated_2_type matrix_q_updated_2;

   typedef double _matrix_q_updated_3_type;
  _matrix_q_updated_3_type matrix_q_updated_3;

   typedef double _current_x_type;
  _current_x_type current_x;

   typedef double _current_y_type;
  _current_y_type current_y;

   typedef double _target_point_x_type;
  _target_point_x_type target_point_x;

   typedef double _target_point_y_type;
  _target_point_y_type target_point_y;

   typedef double _lat_target_point_s_type;
  _lat_target_point_s_type lat_target_point_s;

   typedef int64_t _lqr_calculate_time_type;
  _lqr_calculate_time_type lqr_calculate_time;

   typedef int64_t _lqr_calculate_time_max_type;
  _lqr_calculate_time_max_type lqr_calculate_time_max;





  typedef boost::shared_ptr< ::ros_interface::ControlAnalysis_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ros_interface::ControlAnalysis_<ContainerAllocator> const> ConstPtr;

}; // struct ControlAnalysis_

typedef ::ros_interface::ControlAnalysis_<std::allocator<void> > ControlAnalysis;

typedef boost::shared_ptr< ::ros_interface::ControlAnalysis > ControlAnalysisPtr;
typedef boost::shared_ptr< ::ros_interface::ControlAnalysis const> ControlAnalysisConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ros_interface::ControlAnalysis_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ros_interface::ControlAnalysis_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ros_interface::ControlAnalysis_<ContainerAllocator1> & lhs, const ::ros_interface::ControlAnalysis_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.driving_mode == rhs.driving_mode &&
    lhs.driving_mode_fd == rhs.driving_mode_fd &&
    lhs.gear_location_fd == rhs.gear_location_fd &&
    lhs.gear_location_cmd == rhs.gear_location_cmd &&
    lhs.epb_level_fd == rhs.epb_level_fd &&
    lhs.epb_level_cmd == rhs.epb_level_cmd &&
    lhs.speed_mps == rhs.speed_mps &&
    lhs.speed_reference == rhs.speed_reference &&
    lhs.accel_value_fd == rhs.accel_value_fd &&
    lhs.accel_value_cmd == rhs.accel_value_cmd &&
    lhs.brake_value_fd == rhs.brake_value_fd &&
    lhs.brake_value_cmd == rhs.brake_value_cmd &&
    lhs.path_remain == rhs.path_remain &&
    lhs.has_stop_point == rhs.has_stop_point &&
    lhs.is_full_stop == rhs.is_full_stop &&
    lhs.is_stopped == rhs.is_stopped &&
    lhs.lon_acc_jerk == rhs.lon_acc_jerk &&
    lhs.acceleration_cmd == rhs.acceleration_cmd &&
    lhs.acceleration_cmd_closeloop == rhs.acceleration_cmd_closeloop &&
    lhs.preview_acceleration_reference == rhs.preview_acceleration_reference &&
    lhs.slope_offset_compensation == rhs.slope_offset_compensation &&
    lhs.turning_offset_compensation == rhs.turning_offset_compensation &&
    lhs.speed_error_limited == rhs.speed_error_limited &&
    lhs.speed_error == rhs.speed_error &&
    lhs.speed_offset == rhs.speed_offset &&
    lhs.station_error_limited == rhs.station_error_limited &&
    lhs.station_error == rhs.station_error &&
    lhs.lon_target_point_s == rhs.lon_target_point_s &&
    lhs.lon_calculate_time == rhs.lon_calculate_time &&
    lhs.lon_calculate_time_max == rhs.lon_calculate_time_max &&
    lhs.ref_curvature == rhs.ref_curvature &&
    lhs.ref_heading == rhs.ref_heading &&
    lhs.current_heading == rhs.current_heading &&
    lhs.heading_error == rhs.heading_error &&
    lhs.heading_error_rate == rhs.heading_error_rate &&
    lhs.lateral_error == rhs.lateral_error &&
    lhs.lateral_error_rate == rhs.lateral_error_rate &&
    lhs.lon_error == rhs.lon_error &&
    lhs.front_steering_value_fd == rhs.front_steering_value_fd &&
    lhs.front_steering_target == rhs.front_steering_target &&
    lhs.front_steering_rate == rhs.front_steering_rate &&
    lhs.front_steer_angle_feedforward == rhs.front_steer_angle_feedforward &&
    lhs.front_steer_angle_feedback == rhs.front_steer_angle_feedback &&
    lhs.front_steer_angle_lateral_contribution == rhs.front_steer_angle_lateral_contribution &&
    lhs.front_steer_angle_lateral_rate_contribution == rhs.front_steer_angle_lateral_rate_contribution &&
    lhs.front_steer_angle_heading_contribution == rhs.front_steer_angle_heading_contribution &&
    lhs.front_steer_angle_heading_rate_contribution == rhs.front_steer_angle_heading_rate_contribution &&
    lhs.rear_steering_value_fd == rhs.rear_steering_value_fd &&
    lhs.rear_steering_target == rhs.rear_steering_target &&
    lhs.rear_steering_rate == rhs.rear_steering_rate &&
    lhs.rear_steer_angle_feedforward == rhs.rear_steer_angle_feedforward &&
    lhs.rear_steer_angle_feedback == rhs.rear_steer_angle_feedback &&
    lhs.rear_steer_angle_lateral_contribution == rhs.rear_steer_angle_lateral_contribution &&
    lhs.rear_steer_angle_lateral_rate_contribution == rhs.rear_steer_angle_lateral_rate_contribution &&
    lhs.rear_steer_angle_heading_contribution == rhs.rear_steer_angle_heading_contribution &&
    lhs.rear_steer_angle_heading_rate_contribution == rhs.rear_steer_angle_heading_rate_contribution &&
    lhs.matrix_k_00 == rhs.matrix_k_00 &&
    lhs.matrix_k_01 == rhs.matrix_k_01 &&
    lhs.matrix_k_02 == rhs.matrix_k_02 &&
    lhs.matrix_k_03 == rhs.matrix_k_03 &&
    lhs.matrix_k_10 == rhs.matrix_k_10 &&
    lhs.matrix_k_11 == rhs.matrix_k_11 &&
    lhs.matrix_k_12 == rhs.matrix_k_12 &&
    lhs.matrix_k_13 == rhs.matrix_k_13 &&
    lhs.matrix_state_0 == rhs.matrix_state_0 &&
    lhs.matrix_state_1 == rhs.matrix_state_1 &&
    lhs.matrix_state_2 == rhs.matrix_state_2 &&
    lhs.matrix_state_3 == rhs.matrix_state_3 &&
    lhs.matrix_q_updated_0 == rhs.matrix_q_updated_0 &&
    lhs.matrix_q_updated_1 == rhs.matrix_q_updated_1 &&
    lhs.matrix_q_updated_2 == rhs.matrix_q_updated_2 &&
    lhs.matrix_q_updated_3 == rhs.matrix_q_updated_3 &&
    lhs.current_x == rhs.current_x &&
    lhs.current_y == rhs.current_y &&
    lhs.target_point_x == rhs.target_point_x &&
    lhs.target_point_y == rhs.target_point_y &&
    lhs.lat_target_point_s == rhs.lat_target_point_s &&
    lhs.lqr_calculate_time == rhs.lqr_calculate_time &&
    lhs.lqr_calculate_time_max == rhs.lqr_calculate_time_max;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ros_interface::ControlAnalysis_<ContainerAllocator1> & lhs, const ::ros_interface::ControlAnalysis_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ros_interface

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ros_interface::ControlAnalysis_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_interface::ControlAnalysis_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_interface::ControlAnalysis_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_interface::ControlAnalysis_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_interface::ControlAnalysis_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_interface::ControlAnalysis_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ros_interface::ControlAnalysis_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6457731febea5c324804cbbe27562bf5";
  }

  static const char* value(const ::ros_interface::ControlAnalysis_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6457731febea5c32ULL;
  static const uint64_t static_value2 = 0x4804cbbe27562bf5ULL;
};

template<class ContainerAllocator>
struct DataType< ::ros_interface::ControlAnalysis_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ros_interface/ControlAnalysis";
  }

  static const char* value(const ::ros_interface::ControlAnalysis_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ros_interface::ControlAnalysis_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header   header     #  \n"
"int32   driving_mode     # 驾驶模式\n"
"int32   driving_mode_fd     # 驾驶模式反馈\n"
"int32   gear_location_fd     # 档位反馈\n"
"int32   gear_location_cmd     # 档位命令\n"
"int32   epb_level_fd     # EPB状态反馈\n"
"int32   epb_level_cmd     # EPB命令\n"
"float64   speed_mps     # 车辆速度\n"
"float64   speed_reference     # 参考速度\n"
"float64   accel_value_fd     # 油门反馈\n"
"float64   accel_value_cmd     # 油门命令\n"
"float64   brake_value_fd     # 刹车反馈\n"
"float64   brake_value_cmd     # 刹车命令\n"
"float64   path_remain     # 剩余轨迹里程\n"
"bool   has_stop_point     # 是否有停车点\n"
"bool   is_full_stop     # 是否有停车轨迹\n"
"bool   is_stopped     # 是否停车\n"
"float64   lon_acc_jerk     # 纵向加加速度\n"
"float64   acceleration_cmd     # 加速度命令\n"
"float64   acceleration_cmd_closeloop     # 闭环加速度命令\n"
"float64   preview_acceleration_reference     # 预描参考加速度\n"
"float64   slope_offset_compensation     # 坡道补偿\n"
"float64   turning_offset_compensation     # 转向补偿\n"
"float64   speed_error_limited     # 速度差限值\n"
"float64   speed_error     # 速度差\n"
"float64   speed_offset     #  \n"
"float64   station_error_limited     # 位置误差限值\n"
"float64   station_error     # 位置误差\n"
"float64   lon_target_point_s     # 纵向控制目标点里程\n"
"int64   lon_calculate_time     # 纵向计算时间\n"
"int64   lon_calculate_time_max     # 纵向时间限值\n"
"float64   ref_curvature     # 参考曲率\n"
"float64   ref_heading     # 参考航向角\n"
"float64   current_heading     # 当前航向角\n"
"float64   heading_error     # 航向角误差\n"
"float64   heading_error_rate     # 航向角误差率\n"
"float64   lateral_error     # 横向误差\n"
"float64   lateral_error_rate     # 横向误差率\n"
"float64   lon_error     # 纵向误差\n"
"float64   front_steering_value_fd     # 前轮转向反馈\n"
"float64   front_steering_target     # 前轮目标转向\n"
"float64   front_steering_rate     # 前轮转向角速率\n"
"float64   front_steer_angle_feedforward     # 前轮前馈计算\n"
"float64   front_steer_angle_feedback     # 前轮反馈计算\n"
"float64   front_steer_angle_lateral_contribution     # 前轮横向误差贡献\n"
"float64   front_steer_angle_lateral_rate_contribution     # 前轮横向误差率贡献\n"
"float64   front_steer_angle_heading_contribution     # 前轮航向角误差贡献\n"
"float64   front_steer_angle_heading_rate_contribution     # 前轮航向角误差率贡献\n"
"float64   rear_steering_value_fd     # 后轮转向反馈\n"
"float64   rear_steering_target     # 后轮目标转向\n"
"float64   rear_steering_rate     # 后轮转向角速率\n"
"float64   rear_steer_angle_feedforward     # 后轮前馈计算\n"
"float64   rear_steer_angle_feedback     # 后轮反馈计算\n"
"float64   rear_steer_angle_lateral_contribution     # 后轮横向误差贡献\n"
"float64   rear_steer_angle_lateral_rate_contribution     # 后轮横向误差率贡献\n"
"float64   rear_steer_angle_heading_contribution     # 后轮航向角误差贡献\n"
"float64   rear_steer_angle_heading_rate_contribution     # 后轮航向角误差率贡献\n"
"float64   matrix_k_00     # k矩阵\n"
"float64   matrix_k_01     # k矩阵\n"
"float64   matrix_k_02     # k矩阵\n"
"float64   matrix_k_03     # k矩阵\n"
"float64   matrix_k_10     # k矩阵\n"
"float64   matrix_k_11     # k矩阵\n"
"float64   matrix_k_12     # k矩阵\n"
"float64   matrix_k_13     # k矩阵\n"
"float64   matrix_state_0     # 状态矩阵\n"
"float64   matrix_state_1     # 状态矩阵\n"
"float64   matrix_state_2     # 状态矩阵\n"
"float64   matrix_state_3     # 状态矩阵\n"
"float64   matrix_q_updated_0     # 权重矩阵\n"
"float64   matrix_q_updated_1     # 权重矩阵\n"
"float64   matrix_q_updated_2     # 权重矩阵\n"
"float64   matrix_q_updated_3     # 权重矩阵\n"
"float64   current_x     # 当前位置x\n"
"float64   current_y     # 当前位置y\n"
"float64   target_point_x     # 目标点x\n"
"float64   target_point_y     # 目标点y\n"
"float64   lat_target_point_s     # 横向目标点里程\n"
"int64   lqr_calculate_time     # LQR计算时间\n"
"int64   lqr_calculate_time_max     # LQR计算时间限值\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::ros_interface::ControlAnalysis_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ros_interface::ControlAnalysis_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.driving_mode);
      stream.next(m.driving_mode_fd);
      stream.next(m.gear_location_fd);
      stream.next(m.gear_location_cmd);
      stream.next(m.epb_level_fd);
      stream.next(m.epb_level_cmd);
      stream.next(m.speed_mps);
      stream.next(m.speed_reference);
      stream.next(m.accel_value_fd);
      stream.next(m.accel_value_cmd);
      stream.next(m.brake_value_fd);
      stream.next(m.brake_value_cmd);
      stream.next(m.path_remain);
      stream.next(m.has_stop_point);
      stream.next(m.is_full_stop);
      stream.next(m.is_stopped);
      stream.next(m.lon_acc_jerk);
      stream.next(m.acceleration_cmd);
      stream.next(m.acceleration_cmd_closeloop);
      stream.next(m.preview_acceleration_reference);
      stream.next(m.slope_offset_compensation);
      stream.next(m.turning_offset_compensation);
      stream.next(m.speed_error_limited);
      stream.next(m.speed_error);
      stream.next(m.speed_offset);
      stream.next(m.station_error_limited);
      stream.next(m.station_error);
      stream.next(m.lon_target_point_s);
      stream.next(m.lon_calculate_time);
      stream.next(m.lon_calculate_time_max);
      stream.next(m.ref_curvature);
      stream.next(m.ref_heading);
      stream.next(m.current_heading);
      stream.next(m.heading_error);
      stream.next(m.heading_error_rate);
      stream.next(m.lateral_error);
      stream.next(m.lateral_error_rate);
      stream.next(m.lon_error);
      stream.next(m.front_steering_value_fd);
      stream.next(m.front_steering_target);
      stream.next(m.front_steering_rate);
      stream.next(m.front_steer_angle_feedforward);
      stream.next(m.front_steer_angle_feedback);
      stream.next(m.front_steer_angle_lateral_contribution);
      stream.next(m.front_steer_angle_lateral_rate_contribution);
      stream.next(m.front_steer_angle_heading_contribution);
      stream.next(m.front_steer_angle_heading_rate_contribution);
      stream.next(m.rear_steering_value_fd);
      stream.next(m.rear_steering_target);
      stream.next(m.rear_steering_rate);
      stream.next(m.rear_steer_angle_feedforward);
      stream.next(m.rear_steer_angle_feedback);
      stream.next(m.rear_steer_angle_lateral_contribution);
      stream.next(m.rear_steer_angle_lateral_rate_contribution);
      stream.next(m.rear_steer_angle_heading_contribution);
      stream.next(m.rear_steer_angle_heading_rate_contribution);
      stream.next(m.matrix_k_00);
      stream.next(m.matrix_k_01);
      stream.next(m.matrix_k_02);
      stream.next(m.matrix_k_03);
      stream.next(m.matrix_k_10);
      stream.next(m.matrix_k_11);
      stream.next(m.matrix_k_12);
      stream.next(m.matrix_k_13);
      stream.next(m.matrix_state_0);
      stream.next(m.matrix_state_1);
      stream.next(m.matrix_state_2);
      stream.next(m.matrix_state_3);
      stream.next(m.matrix_q_updated_0);
      stream.next(m.matrix_q_updated_1);
      stream.next(m.matrix_q_updated_2);
      stream.next(m.matrix_q_updated_3);
      stream.next(m.current_x);
      stream.next(m.current_y);
      stream.next(m.target_point_x);
      stream.next(m.target_point_y);
      stream.next(m.lat_target_point_s);
      stream.next(m.lqr_calculate_time);
      stream.next(m.lqr_calculate_time_max);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ControlAnalysis_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ros_interface::ControlAnalysis_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ros_interface::ControlAnalysis_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "driving_mode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.driving_mode);
    s << indent << "driving_mode_fd: ";
    Printer<int32_t>::stream(s, indent + "  ", v.driving_mode_fd);
    s << indent << "gear_location_fd: ";
    Printer<int32_t>::stream(s, indent + "  ", v.gear_location_fd);
    s << indent << "gear_location_cmd: ";
    Printer<int32_t>::stream(s, indent + "  ", v.gear_location_cmd);
    s << indent << "epb_level_fd: ";
    Printer<int32_t>::stream(s, indent + "  ", v.epb_level_fd);
    s << indent << "epb_level_cmd: ";
    Printer<int32_t>::stream(s, indent + "  ", v.epb_level_cmd);
    s << indent << "speed_mps: ";
    Printer<double>::stream(s, indent + "  ", v.speed_mps);
    s << indent << "speed_reference: ";
    Printer<double>::stream(s, indent + "  ", v.speed_reference);
    s << indent << "accel_value_fd: ";
    Printer<double>::stream(s, indent + "  ", v.accel_value_fd);
    s << indent << "accel_value_cmd: ";
    Printer<double>::stream(s, indent + "  ", v.accel_value_cmd);
    s << indent << "brake_value_fd: ";
    Printer<double>::stream(s, indent + "  ", v.brake_value_fd);
    s << indent << "brake_value_cmd: ";
    Printer<double>::stream(s, indent + "  ", v.brake_value_cmd);
    s << indent << "path_remain: ";
    Printer<double>::stream(s, indent + "  ", v.path_remain);
    s << indent << "has_stop_point: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.has_stop_point);
    s << indent << "is_full_stop: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_full_stop);
    s << indent << "is_stopped: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_stopped);
    s << indent << "lon_acc_jerk: ";
    Printer<double>::stream(s, indent + "  ", v.lon_acc_jerk);
    s << indent << "acceleration_cmd: ";
    Printer<double>::stream(s, indent + "  ", v.acceleration_cmd);
    s << indent << "acceleration_cmd_closeloop: ";
    Printer<double>::stream(s, indent + "  ", v.acceleration_cmd_closeloop);
    s << indent << "preview_acceleration_reference: ";
    Printer<double>::stream(s, indent + "  ", v.preview_acceleration_reference);
    s << indent << "slope_offset_compensation: ";
    Printer<double>::stream(s, indent + "  ", v.slope_offset_compensation);
    s << indent << "turning_offset_compensation: ";
    Printer<double>::stream(s, indent + "  ", v.turning_offset_compensation);
    s << indent << "speed_error_limited: ";
    Printer<double>::stream(s, indent + "  ", v.speed_error_limited);
    s << indent << "speed_error: ";
    Printer<double>::stream(s, indent + "  ", v.speed_error);
    s << indent << "speed_offset: ";
    Printer<double>::stream(s, indent + "  ", v.speed_offset);
    s << indent << "station_error_limited: ";
    Printer<double>::stream(s, indent + "  ", v.station_error_limited);
    s << indent << "station_error: ";
    Printer<double>::stream(s, indent + "  ", v.station_error);
    s << indent << "lon_target_point_s: ";
    Printer<double>::stream(s, indent + "  ", v.lon_target_point_s);
    s << indent << "lon_calculate_time: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lon_calculate_time);
    s << indent << "lon_calculate_time_max: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lon_calculate_time_max);
    s << indent << "ref_curvature: ";
    Printer<double>::stream(s, indent + "  ", v.ref_curvature);
    s << indent << "ref_heading: ";
    Printer<double>::stream(s, indent + "  ", v.ref_heading);
    s << indent << "current_heading: ";
    Printer<double>::stream(s, indent + "  ", v.current_heading);
    s << indent << "heading_error: ";
    Printer<double>::stream(s, indent + "  ", v.heading_error);
    s << indent << "heading_error_rate: ";
    Printer<double>::stream(s, indent + "  ", v.heading_error_rate);
    s << indent << "lateral_error: ";
    Printer<double>::stream(s, indent + "  ", v.lateral_error);
    s << indent << "lateral_error_rate: ";
    Printer<double>::stream(s, indent + "  ", v.lateral_error_rate);
    s << indent << "lon_error: ";
    Printer<double>::stream(s, indent + "  ", v.lon_error);
    s << indent << "front_steering_value_fd: ";
    Printer<double>::stream(s, indent + "  ", v.front_steering_value_fd);
    s << indent << "front_steering_target: ";
    Printer<double>::stream(s, indent + "  ", v.front_steering_target);
    s << indent << "front_steering_rate: ";
    Printer<double>::stream(s, indent + "  ", v.front_steering_rate);
    s << indent << "front_steer_angle_feedforward: ";
    Printer<double>::stream(s, indent + "  ", v.front_steer_angle_feedforward);
    s << indent << "front_steer_angle_feedback: ";
    Printer<double>::stream(s, indent + "  ", v.front_steer_angle_feedback);
    s << indent << "front_steer_angle_lateral_contribution: ";
    Printer<double>::stream(s, indent + "  ", v.front_steer_angle_lateral_contribution);
    s << indent << "front_steer_angle_lateral_rate_contribution: ";
    Printer<double>::stream(s, indent + "  ", v.front_steer_angle_lateral_rate_contribution);
    s << indent << "front_steer_angle_heading_contribution: ";
    Printer<double>::stream(s, indent + "  ", v.front_steer_angle_heading_contribution);
    s << indent << "front_steer_angle_heading_rate_contribution: ";
    Printer<double>::stream(s, indent + "  ", v.front_steer_angle_heading_rate_contribution);
    s << indent << "rear_steering_value_fd: ";
    Printer<double>::stream(s, indent + "  ", v.rear_steering_value_fd);
    s << indent << "rear_steering_target: ";
    Printer<double>::stream(s, indent + "  ", v.rear_steering_target);
    s << indent << "rear_steering_rate: ";
    Printer<double>::stream(s, indent + "  ", v.rear_steering_rate);
    s << indent << "rear_steer_angle_feedforward: ";
    Printer<double>::stream(s, indent + "  ", v.rear_steer_angle_feedforward);
    s << indent << "rear_steer_angle_feedback: ";
    Printer<double>::stream(s, indent + "  ", v.rear_steer_angle_feedback);
    s << indent << "rear_steer_angle_lateral_contribution: ";
    Printer<double>::stream(s, indent + "  ", v.rear_steer_angle_lateral_contribution);
    s << indent << "rear_steer_angle_lateral_rate_contribution: ";
    Printer<double>::stream(s, indent + "  ", v.rear_steer_angle_lateral_rate_contribution);
    s << indent << "rear_steer_angle_heading_contribution: ";
    Printer<double>::stream(s, indent + "  ", v.rear_steer_angle_heading_contribution);
    s << indent << "rear_steer_angle_heading_rate_contribution: ";
    Printer<double>::stream(s, indent + "  ", v.rear_steer_angle_heading_rate_contribution);
    s << indent << "matrix_k_00: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_k_00);
    s << indent << "matrix_k_01: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_k_01);
    s << indent << "matrix_k_02: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_k_02);
    s << indent << "matrix_k_03: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_k_03);
    s << indent << "matrix_k_10: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_k_10);
    s << indent << "matrix_k_11: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_k_11);
    s << indent << "matrix_k_12: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_k_12);
    s << indent << "matrix_k_13: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_k_13);
    s << indent << "matrix_state_0: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_state_0);
    s << indent << "matrix_state_1: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_state_1);
    s << indent << "matrix_state_2: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_state_2);
    s << indent << "matrix_state_3: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_state_3);
    s << indent << "matrix_q_updated_0: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_q_updated_0);
    s << indent << "matrix_q_updated_1: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_q_updated_1);
    s << indent << "matrix_q_updated_2: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_q_updated_2);
    s << indent << "matrix_q_updated_3: ";
    Printer<double>::stream(s, indent + "  ", v.matrix_q_updated_3);
    s << indent << "current_x: ";
    Printer<double>::stream(s, indent + "  ", v.current_x);
    s << indent << "current_y: ";
    Printer<double>::stream(s, indent + "  ", v.current_y);
    s << indent << "target_point_x: ";
    Printer<double>::stream(s, indent + "  ", v.target_point_x);
    s << indent << "target_point_y: ";
    Printer<double>::stream(s, indent + "  ", v.target_point_y);
    s << indent << "lat_target_point_s: ";
    Printer<double>::stream(s, indent + "  ", v.lat_target_point_s);
    s << indent << "lqr_calculate_time: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lqr_calculate_time);
    s << indent << "lqr_calculate_time_max: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lqr_calculate_time_max);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROS_INTERFACE_MESSAGE_CONTROLANALYSIS_H
